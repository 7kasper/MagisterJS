<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Magister.coffee - Magister.js Docs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://i.imgur.com/Lrg80ax.png" title="Magister.js Docs"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.7.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Appointment.html">Appointment</a></li>
                                <li><a href="../classes/Assignment.html">Assignment</a></li>
                                <li><a href="../classes/AssignmentVersion.html">AssignmentVersion</a></li>
                                <li><a href="../classes/Class.html">Class</a></li>
                                <li><a href="../classes/Course.html">Course</a></li>
                                <li><a href="../classes/DetailedProfileInfo.html">DetailedProfileInfo</a></li>
                                <li><a href="../classes/DigitalSchoolUtility.html">DigitalSchoolUtility</a></li>
                                <li><a href="../classes/File.html">File</a></li>
                                <li><a href="../classes/FileFolder.html">FileFolder</a></li>
                                <li><a href="../classes/Grade.html">Grade</a></li>
                                <li><a href="../classes/GradePeriod.html">GradePeriod</a></li>
                                <li><a href="../classes/GradeType.html">GradeType</a></li>
                                <li><a href="../classes/Magister.html">Magister</a></li>
                                <li><a href="../classes/MagisterSchool.html">MagisterSchool</a></li>
                                <li><a href="../classes/Message.html">Message</a></li>
                                <li><a href="../classes/MessageFolder.html">MessageFolder</a></li>
                                <li><a href="../classes/Person.html">Person</a></li>
                                <li><a href="../classes/ProfileInfo.html">ProfileInfo</a></li>
                                <li><a href="../classes/StudyGuide.html">StudyGuide</a></li>
                                <li><a href="../classes/StudyGuidePart.html">StudyGuidePart</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Magister.html">Magister</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: Magister.coffee</h1>

<div class="file">
    <pre class="code prettyprint linenums">
root = (module?.exports ? this.Magister ?= {})
if Meteor?
	@_ = _ = lodash
else if module?.exports? and require? and not window?
	@_ = _ = require(&quot;lodash&quot;) if not _?
else if @_?
	_ = @_
else
	throw new Error &quot;Lo-dash is required.&quot;

###*
# The version of this Magister.js.
# @property VERSION
# @final
# @type String
###
root.VERSION = &quot;1.7.0&quot;

###*
# A JavaScript implementation of the Magister 6 API.
# @author Lieuwe Rooijakkers
# @module Magister
###

###*
# Class to communicate with Magister.
#
# @class Magister
# @param options {Object} An object containing your perfered options.
#	 @param options.school {MagisterSchool|String} A MagisterSchool to logon to. If this is a String it will use that String as a query to search for a possible school.
#	 @param [options.username] {String} The username of the user to login to. (Not needed when using an sessionId.)
#	 @param [options.password] {String} The password of the user to login to. (Not needed when using an sessionId.)
#	 @param [options.sessionId] {String} An sessionId to use instead of logigging in to retreive a new one.
#	 @param [options.keepLoggedIn=true] {Boolean} Whether or not to keep the user logged in.
# @constructor
###
class root.Magister
	constructor: -&gt;
		options = keepLoggedIn: yes

		if arguments.length is 1 and _.isObject arguments[0] # Options object.
			options = _.extend options, arguments[0]
		else # Backwards compatibility.
			throw new Error &quot;Expected 3 or 4 arguments, got #{arguments.length}&quot; unless arguments.length is 3 or arguments.length is 4

			school = arguments[0]
			username = arguments[1]
			password = arguments[2]
			keepLoggedIn = arguments[3]

			options = _.extend options, { school, username, password, keepLoggedIn }

		@_readyCallbacks = [] # Fixes weird bug where callbacks from previous Magister objects were mixed with the new ones.
		@http = new root.MagisterHttp()

		@magisterSchool = options.school
		@username = options.username
		@password = options.password
		@_keepLoggedIn = options.keepLoggedIn

		if _.isString(@magisterSchool)
			root.MagisterSchool.getSchools @magisterSchool, (e, r) =&gt;
				if e? then @_setErrored e
				else if r.length is 0 then @_setErrored new Error &quot;No school with the query #{@magisterSchool} found.&quot;
				else
					@magisterSchool = r[0]
					@_reLogin options.sessionId

		else @_reLogin options.sessionId

	###*
	# Get the appoinments of the current User between the two given Dates.
	#
	# @method appointments
	# @async
	# @param from {Date} The start date for the Appointments, you won&#x27;t get appointments from before this date.
	# @param [to] {Date} The end date for the Appointments, you won&#x27;t get appointments from after this date.
	# @param [fillPersons=false] {Boolean} Whether or not to download the full user objects from the server.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Appointment[]} An array containing the Appointments.
	###
	appointments: -&gt;
		callback = _.find arguments, (a) -&gt; _.isFunction a
		fillPersons = _.find(arguments, (a) -&gt; _.isBoolean a) ? no
		[from, to] = _.where arguments, (a) -&gt; _.isDate a
		unless _.isDate(to) then to = from

		from = root._helpers.date from
		to = root._helpers.date to

		@_forceReady()
		dateConvert = root._helpers.urlDateConvert
		url = &quot;#{@_personUrl}/afspraken?tot=#{dateConvert(to)}&amp;van=#{dateConvert(from)}&quot;
		@http.get url, {}, (error, result) =&gt;
				if error? then callback error, null
				else
					result = JSON.parse result.content
					appointments = (root.Appointment._convertRaw(this, a) for a in result.Items)

					absenceInfo = []
					changedAppointments = []

					finish = root._helpers.asyncResultWaiter 3, (r) -&gt;
						_.each appointments, (a) -&gt; a._absenceInfo = _.find absenceInfo, (absence) -&gt; absence.appointmentId is a.id()

						appointments = _(appointments)
							.reject (a) -&gt; _.contains changedAppointments, (changedAppointment) -&gt; changedAppointment.id() is a.id()
							.concat changedAppointments
							.filter (a) -&gt; root._helpers.date(a.begin()) &lt;= to and root._helpers.date(a.end()) &gt;= from
							.sortBy &quot;_begin&quot;
							.value()

						callback null, appointments

					# Get changedAppointments.
					@http.get &quot;#{@_personUrl}/roosterwijzigingen?tot=#{dateConvert(to)}&amp;van=#{dateConvert(from)}&quot;, {}, (error, result) =&gt;
						if error?
							callback error, null
						else
							result = JSON.parse result.content
							changedAppointments.concat (root.Appointment._convertRaw(this, a) for a in result.Items)
							finish()

					# Get absenceInfo.
					@http.get &quot;#{@_personUrl}/absenties?tot=#{dateConvert(to)}&amp;van=#{dateConvert(from)}&quot;, {}, (error, result) -&gt;
						if error?
							callback error, null
						else
							result = JSON.parse(result.content).Items
							for a in result
								absenceInfo.push
									id: a.Id
									begin: new Date Date.parse a.Start
									end: new Date Date.parse a.Eind
									schoolHour: a.Lesuur
									permitted: a.Geoorloofd
									appointmentId: a.AfspraakId
									description: a.Omschrijving.trim()
									type: a.VerantwoordingType
									code: a.Code
							finish()

					# Get persons.
					if fillPersons
						pushResult = root._helpers.asyncResultWaiter appointments.length, -&gt; finish()

						for a in appointments then do (a) =&gt;
							teachers = a.teachers()

							@fillPersons teachers, ((e, r) -&gt;
								a._teachers = r
								pushResult()
							), 3
					else finish()

	###*
	# Gets the MessageFolders that matches the given query. Or if no query is given, all MessageFolders
	#
	# @method messageFolders
	# @param [query] {String} A case insensetive query the MessageFolder need to match.
	# @param [callback] {Function} If a callback is given, the message folders will be refetched.
	#	@param [callback.error] {Object} The error, if it exists.
	#	@param [callback.result] {MessageFolder[]} An array containing the matching MessageFolders.
	# @return {MessageFolder[]|undefined} An array containing the matching messageFolders or undefined if a callback is given.
	###
	messageFolders: (query, callback) -&gt;
		@_forceReady()

		if callback?
			@_fetchMessageFolders (e, r) =&gt;
				if e? then callback e, null
				else callback null, @messageFolders query
			return undefined

		query = query.trim()

		if _.isString(query) and query isnt &quot;&quot;
			result = _.where @_messageFolders, (mF) -&gt; root._helpers.contains mF.name(), query, yes
		else
			result = @_messageFolders

		result

	###*
	# Fetches the messageFolders for the current Magister object.
	#
	# @method _fetchMessageFolders
	# @private
	# @param callback {Function}
	# 	@param [callback.error] {Object} The error, if it exists.
	###
	_fetchMessageFolders: (callback) -&gt;
		@http.get &quot;#{@_personUrl}/berichten/mappen&quot;, {}, (e, r) =&gt;
			if e?
				e.statusCode = result?.statusCode
				callback e
			else
				@_messageFolders = (root.MessageFolder._convertRaw(this, m) for m in JSON.parse(r.content).Items)
				callback null

	###*
	# @method inbox
	# @return {MessageFolder} The inbox of the current user.
	###
	inbox: -&gt; @messageFolders(&quot;postvak in&quot;)[0]
	###*
	# @method sentItems
	# @return {MessageFolder} The sent items folder of the current user.
	###
	sentItems: -&gt; @messageFolders(&quot;verzonden items&quot;)[0]
	###*
	# @method bin
	# @return {MessageFolder} The bin of the current user.
	###
	bin: -&gt; @messageFolders(&quot;verwijderde items&quot;)[0]
	###*
	# @method alerts
	# @return {MessageFolder} The alerts folder of the current user.
	###
	alerts: -&gt; @messageFolders(&quot;mededelingen&quot;)[0]

	###*
	# Gets the courses of the current User.
	#
	# @method courses
	# @async
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Course[]} An array containing the Courses.
	###
	courses: (callback) -&gt;
		@_forceReady()
		url = &quot;#{@_personUrl}/aanmeldingen&quot;

		@http.get url, {},
			(error, result) =&gt;
				if error?
					callback error, null
				else
					result = JSON.parse result.content
					converted = (root.Course._convertRaw(this, c) for c in result.Items)
					callback null, _(converted).sortBy(&quot;_beginDate&quot;).sortBy((x) -&gt; not x._current).value()

	###*
	# Gets the current grade of the current User.
	#
	# @method currentCourse
	# @async
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Course} An array containing the current Course.
	###
	currentCourse: (callback) -&gt;
		@_forceReady()
		@courses (e, r) -&gt;
			if e? then callback e, null
			else callback null, _.find r, (c) -&gt; c.current()

	###*
	# Gets limited course info for the current Course for the current User.
	#
	# This is quicker than &#x60;courses&#x60;, however it&#x27;s not as consistent and
	# doesn&#x27;t really fit in Magister.js&#x27;s style, however if you know what
	# you&#x27;re doing and you&#x27;re willing to use this, go ahead.
	#
	# @method getLimitedCurrentCourseInfo
	# @async
	# @deprecated &#x60;courses&#x60; is prefered.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Object} The limited course info.
	# 		@param [callback.result.group] {String}
	# 		@param [callback.result.profile] {String}
	# 		@param [callback.result.pupilId] {any}
	# 		@param [callback.result.type] {Object}
	# 			@param [callback.result.type.year] {Number}
	# 			@param [callback.result.type.schoolVariant] {String}
	###
	getLimitedCurrentCourseInfo: (callback) -&gt;
		@_forceReady()
		url = &quot;#{@_personUrl}/opleidinggegevensprofiel&quot;

		@http.get url, {}, (error, result) -&gt;
			if error? then callback error, null
			else
				parsed = JSON.parse result.content
				callback null,
					group: parsed.Klas
					profile: parsed.Profielen # It says &#x27;profielen&#x27; but I really have no idea how multiple profiles are shown in a String...
					pupilId: parsed.StamNr # Should be the same as &#x60;@userName&#x60; AFAIK.
					type:
						year: +/\d+/.exec(parsed.Studie)[0]
						schoolVariant: /[^\d\s]+/.exec(parsed.Studie)[0]

	@_cachedPersons: {}
	###*
	# Gets an Array of Persons that matches the given profile.
	#
	# @method getPersons
	# @async
	# @param query {String} The query the persons must match to (e.g: Surname, Name, ...). Should at least be 3 chars long.
	# @param [type] {String|Number} The type the person must have. If none is given it will search for both Teachers and Pupils.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Person[]} An array containing the Persons.
	# @return {Boolean} True if cached result was used, false otherwise.
	###
	getPersons: -&gt;
		@_forceReady()

		[query, type] = _.filter arguments, (a) -&gt; _.isNumber(a) or _.isString(a)
		callback = _.find arguments, (a) -&gt; _.isFunction a

		unless query? and callback? and query.length &gt;= 3
			callback null, []
			return false

		query = query.trim()

		unless type? # Try both Teachers and Pupils
			# best varname award goes to...
			b1 = b2 = no
			b1 = @getPersons query, 3, (e, r) =&gt;
				if e? then callback e, null
				else
					teachers = r
					b2 = @getPersons query, 4, (e, r) -&gt;
						if e? then callback e, null
						else callback null, root._helpers.pushMore r, teachers
			return b1 or b2

		try
			type = root.Person._convertType type
			queryType = switch type
				when 3 then &quot;Personeel&quot;
				when 4 then &quot;Leerling&quot;
				when 8 then &quot;Project&quot;

				else &quot;Overig&quot;
		catch e # parse error, most likely
			callback e, undefined
			return false
		url = &quot;#{@_personUrl}/contactpersonen?contactPersoonType=#{queryType}&amp;q=#{query.replace /\ +/g, &quot;+&quot;}&quot;

		if (val = root.Magister._cachedPersons[&quot;#{@_id}#{type}#{query}&quot;])?
			if process?.nextTick?
				process.nextTick -&gt; callback null, val
			else
				_.defer callback, null, val
			true
		else
			@http.get url, {}, (error, result) =&gt;
				if error?
					callback error, null
				else
					result = (root.Person._convertRaw(this, p, type) for p in JSON.parse(result.content).Items)
					root.Magister._cachedPersons[&quot;#{@_id}#{type}#{query}&quot;] = result
					callback null, result
			false

	###*
	# Fills the given person(s) by downloading the person from Magister and replacing the local instance.
	#
	# @method fillPersons
	# @async
	# @param persons {Person|Person[]} A Person or an Array of Persons to fetch more information for.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Person|Person[]} A fetched person or an array containing the fetched Persons, according to the type of the given persons parameter.
	# @param [overwriteType] {Number|String} Not recommended. Forces the type used to search the persons for.
	###
	fillPersons: (persons, callback, overwriteType) -&gt;
		@_forceReady()

		if _.isArray persons
			if persons.length is 0
				callback null, []
				return undefined

			pushResult = root._helpers.asyncResultWaiter persons.length, (r) -&gt; callback null, r

			for p in persons
				try
					@getPersons _.last(p.fullName().split &quot; &quot;), (p._type ? overwriteType), (e, r) -&gt;
						pushResult r[0] ? p
				catch
					pushResult p

		else if _.isObject persons
			try
				@getPersons _.last(persons.fullName().split &quot; &quot;), (persons._type ? overwriteType), (e, r) -&gt;
					callback null, r[0] ? persons
			catch
				callback null, persons

		else
			throw new Error &quot;Expected persons to be an Array or an Object, got a(n) #{typeof persons}&quot;

		return undefined

	###*
	# Shortcut for composing and sending a Message.
	#
	# @method composeAndSendMessage
	# @param subject {String} The subject of the message
	# @param [body] {String} The body of the message, if none is given the body will be empty.
	# @param recipients {Person[]|String[]|Person|String} The recipient(s) the message will be sent to.
	# @param [callback] {Function} An optional callback.
	# 	@param [callback.error] {Object} An error, if it exists.
	# 	@param [callback.result] {Message} The sent message.
	###
	composeAndSendMessage: -&gt;
		@_forceReady()

		[subject, body] = _.filter arguments, (a) -&gt; _.isString a
		callback = _.find arguments, (a) -&gt; _.isFunction a
		recipients = _.findLast arguments, (a) -&gt; a isnt callback
		if arguments.length is 2 then body = &quot;&quot;

		m = new root.Message this
		m.subject subject
		m.body body ? &quot;&quot;
		m.addRecipient recipients
		m.send callback

	###*
	# Gets the FileFolders of the current user.
	#
	# @method fileFolders
	# @async
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {FileFolder[]} An array containing FileFolders.
	###
	fileFolders: (callback) -&gt;
		@_forceReady()

		@http.get &quot;#{@_personUrl}/bronnen?soort=0&quot;, {}, (error, result) =&gt;
			if error? then callback error, null
			else callback null, ( root.FileFolder._convertRaw this, f for f in JSON.parse(result.content).Items )

	###*
	# Gets the StudyGuides of the current user.
	#
	# @method studyGuides
	# @async
	# @param [fillClass=true] {Boolean} Whether or not to download the full class objects from the server. If this is false StudyGuide.class() will return null. (You can use &#x60;StudyGuide.classCodes&#x60; instead then.)
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {StudyGuide[]} An array containing StudyGuides.
	###
	studyGuides: (callback) -&gt;
		@_forceReady()

		fillClass = _.find(arguments, (a) -&gt; _.isBoolean a) ? yes
		callback = _.find arguments, (a) -&gt; _.isFunction a

		cb = (classes) =&gt;
			@http.get &quot;#{@_pupilUrl}/studiewijzers?peildatum=#{root._helpers.urlDateConvert new Date}&quot;, {}, (error, result) =&gt;
				if error? then callback error, null
				else
					result = ( root.StudyGuide._convertRaw this, s for s in JSON.parse(result.content).Items )

					for studyGuide in result then do (studyGuide) -&gt;
						if classes? then studyGuide._class = _.find classes, (c) -&gt; c.abbreviation() is studyGuide._class
						else studyGuide._class = null

					callback null, result

		if fillClass
			@courses (e, r) -&gt;
				if r? and r.length isnt 0
					r[0].classes (e, r) -&gt;
						if r? and r.length isnt 0 then cb r
						else cb()
				else cb()
		else cb()

	###*
	# Gets the Assignments for the current user.
	#
	# @method assignments
	# @async
	# @param [amount=50] {Number} The amount of Assignments to fetch from the server.
	# @param [skip=0] {Number} The amount of Assignments to skip.
	# @param [fillPersons=false] {Boolean} Whether or not to download the full user objects from the server.
	# @param [fillClass=true] {Boolean} Whether or not to download the full class objects from the server. If this is false Assignment.class() will return null.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Assignment[]} An array containing Assignments.
	###
	assignments: -&gt;
		@_forceReady()

		[amount, skip] = _.filter arguments, (a) -&gt; _.isNumber a
		[fillPersons, fillClass] = _.filter arguments, (a) -&gt; _.isBoolean a
		callback = _.find arguments, (a) -&gt; _.isFunction a

		return unless callback?
		fillPersons ?= no
		fillClass ?= yes
		amount ?= 50
		skip ?= 0

		cb = (classes) =&gt;
			@http.get &quot;#{@_personUrl}/opdrachten?skip=#{skip}&amp;top=#{amount}&amp;status=alle&quot;, {}, (error, result) =&gt;
				if error? then callback error, null
				else
					result = (e.Id for e in JSON.parse(result.content).Items)
					pushResult = root._helpers.asyncResultWaiter result.length, (r) -&gt; callback null, r

					for id in result
						@http.get &quot;#{@_personUrl}/opdrachten/#{id}&quot;, {}, (error, result) =&gt;
							assignment = root.Assignment._convertRaw this, JSON.parse(result.content)

							if classes? then assignment._class = _.find classes, (c) -&gt; c.abbreviation() is assignment._class
							else assignment._class = null

							if fillPersons
								teachers = assignment.teachers() ? []

								@fillPersons teachers, ((e, r) -&gt;
									assignment._teachers = r
									pushResult assignment
								), 3

							else pushResult assignment

		if fillClass
			@courses (e, r) -&gt;
				if r? and r.length isnt 0
					r[0].classes (e, r) -&gt;
						if r? and r.length isnt 0 then cb r
						else cb()
				else cb()
		else cb()

	###*
	# Gets the Digital school utilities for the current user.
	#
	# @method digitalSchoolUtilities
	# @async
	# @param [fillClass=true] {Boolean} Whether or not to download the full class objects from the server. If this is false .class() will return a limited class object.
	# @fixme /NOT WORKING/ (Weird ID mismatch) @param [class] {Class|Number} The class or ID of a class to get the Digital school utitlities for. If none is given it will return every DigitalSchoolUtility.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {DigitalSchoolUtility[]} An array containing DigitalSchoolUtilities.
	###
	digitalSchoolUtilities: -&gt;
		@_forceReady()

		fillClass = _.find(arguments, (a) -&gt; _.isBoolean a) ? yes
		#_class = _.find arguments, (a) -&gt; _.isNumber a or _.isObject a
		callback = _.find arguments, (a) -&gt; _.isFunction a
		return unless callback?

		_class = _class.id() if _.isObject _class

		url = if _class? then &quot;#{@_personUrl}/lesmateriaal?vakken=#{_class}&quot; else &quot;#{@_personUrl}/lesmateriaal&quot;

		cb = (classes) =&gt;
			@http.get url, {}, (error, result) =&gt;
				if error? then callback error, null
				else
					utilities = ( root.DigitalSchoolUtility._convertRaw this, u for u in JSON.parse(result.content).Items )

					if classes? then for u in utilities
						do (u) -&gt;
							u._class = _.find classes, (c) -&gt; c.abbreviation() is u._class.Afkorting and c.description() is u._class.Omschrijving

					else for u in utilities
						do (u) =&gt; u._class = root.Class._convertRaw this, u._class

					callback null, utilities

		if fillClass
			@courses (e, r) -&gt;
				if r? and r.length isnt 0
					_.last(r).classes (e, r) -&gt;
						cb r
		else cb()

	###*
	# Returns the profile for the current logged in user.
	#
	# @method profileInfo
	# @param [callback] {Function} Not useful at all, just here to prevent possible mistakes.
	#	@param [callback.error] {Null} Will always be null
	#	@param [callback.result] {ProfileInfo} The profile of the current logged in user.
	# @return {ProfileInfo} The profile of the current logged in user.
	###
	profileInfo: (callback) -&gt;
		@_forceReady()

		callback? null, @_profileInfo
		return @_profileInfo

	###*
	# Returns the children of the current user.
	#
	# @method children
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {ProfileInfo[]} An array containing ProfileInfo instances.
	###
	children: (callback) -&gt;
		@http.get &quot;#{@_personUrl}/kinderen&quot;, {}, (error, result) =&gt;
			if error? then callback error, null
			else
				parsed = JSON.parse(result.content)
				if parsed.ExceptionId? and parsed.Reason is 1
					callback _.extend(parsed, message: &quot;User is not a parent.&quot;), null
					return

				res = []
				for raw in parsed.Items
					c = root.ProfileInfo._convertRaw this, c
					c._profilePicture = &quot;#{@magisterSchool.url}/api/personen/#{raw.Id}/foto&quot;
					c.magister (callback) =&gt;
						r = _.clone this
						r._id = raw.Id
						r._personUrl = &quot;#{@magisterSchool.url}/api/personen/#{r._id}&quot;
						r._pupilUrl = &quot;#{@magisterSchool.url}/api/leerlingen/#{r._id}&quot;
						r._profileInfo = c
						@http.get &quot;#{r._personUrl}/berichten/mappen&quot;, {}, (error, result) -&gt;
							r._messageFolders = (root.MessageFolder._convertRaw(r, m) for m in JSON.parse(result.content).Items)
							callback r
						return undefined
					res.push c

				callback null, res

	###*
	# Checks if this Magister instance is done logging in.
	#
	# You can also provide a callback, which will be called when this instance is done logging in.
	#
	# @method ready
	# @param [callback] {Function} The callback which will be called if the current instance is done logging in.
	# 	@param [callback.error] {Object} A error that occured when logging onto Magister, if it exists.
	# 		@param [callback.error.statusCode] {Number} If the error is returned over HTTP, the statusCode that was returned.
	# 	@param callback.this {Magister} The current Magister object.
	# @return {Boolean} Whether or not the current Magister instance is done logging in.
	###
	ready: (callback) -&gt;
		if _.isFunction callback
			callback = _.bind callback, this
			if @_ready or @_magisterLoadError? then callback @_magisterLoadError
			else @_readyCallbacks.push callback
		@_ready is yes

	_forceReady: -&gt; throw new Error &quot;Not done with logging in or errored during logging in! (did you use Magister.ready(callback) to be sure that logging in is done?)&quot; unless @_ready
	_setReady: -&gt;
		@_ready = yes
		callback() for callback in @_readyCallbacks
		@_readyCallbacks = []

	_setErrored: (e, statusCode) -&gt;
		try
			parsed = JSON.parse e
			@_magisterLoadError = {}
			# Copy all keys of the error Magister gave us, but lowerCase the keys.
			for key of parsed
				@_magisterLoadError[key.toLowerCase()] = parsed[key]
		catch
			@_magisterLoadError = e

		@_magisterLoadError.statusCode = statusCode if statusCode?

		callback @_magisterLoadError for callback in @_readyCallbacks
		@_readyCallbacks = []

	_readyCallbacks: []
	_magisterLoadError: null

	###*
	# (Re-)Login the current Magister instance.
	#
	# Usually not needed to call manually.
	#
	# @method _reLogin
	# @param [sessionId] {String} An optional sessionId to use. Shortens login process.
	# @private
	###
	_reLogin: (sessionId) -&gt;
		@_ready = no
		@_magisterLoadError = null
		@magisterSchool.url = @magisterSchool.url.replace /^https?/, &quot;https&quot; # Force HTTPS.
		url = &quot;#{@magisterSchool.url}/api/sessie&quot;

		cb = (sessionId) =&gt;
			try
				@_sessionId = sessionId
				@http._cookie = &quot;SESSION_ID=#{@_sessionId}; M6UserName=#{@username}&quot;
				@http.get &quot;#{@magisterSchool.url}/api/account&quot;, {},
					(error, result) =&gt;
						if error? then @_setErrored error, result?.statusCode; return

						try
							result = JSON.parse result.content
							@_group = result.Groep[0]
							@_id = result.Persoon.Id
							@_personUrl = &quot;#{@magisterSchool.url}/api/personen/#{@_id}&quot;
							@_pupilUrl = &quot;#{@magisterSchool.url}/api/leerlingen/#{@_id}&quot;
							@_profileInfo = root.ProfileInfo._convertRaw this, result
						catch e then @_setErrored e

						@_fetchMessageFolders (e, r) =&gt;
							if e? then @_setErrored e, e.statusCode
							else @_setReady()

			catch e then @_setErrored e

		if sessionId? then cb sessionId
		else
			@http.post url,
				Gebruikersnaam: @username
				Wachtwoord: @password
				GebruikersnaamOnthouden: yes
				# If this works for every school, we actually wouldn&#x27;t need a &quot;relogin&quot; method. We will keep it and then see how it goes.
				IngelogdBlijven: @_keepLoggedIn
			, { headers: &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot; }, (error, result) =&gt;
				if error? then @_setErrored error
				else if result.content? # Normally the response doesn&#x27;t contain a body, if it contains one it&#x27;s probaly an error.
					@_setErrored result.content
				else
					cb /[a-z\d-]+/.exec(result.headers[&quot;set-cookie&quot;][0])[0]

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
