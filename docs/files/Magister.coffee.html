<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Magister.coffee - Magister.js Docs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://i.imgur.com/Lrg80ax.png" title="Magister.js Docs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Appointment.html">Appointment</a></li>
            
                <li><a href="../classes/Assignment.html">Assignment</a></li>
            
                <li><a href="../classes/AssignmentVersion.html">AssignmentVersion</a></li>
            
                <li><a href="../classes/Class.html">Class</a></li>
            
                <li><a href="../classes/Course.html">Course</a></li>
            
                <li><a href="../classes/DigitalSchoolUtility.html">DigitalSchoolUtility</a></li>
            
                <li><a href="../classes/File.html">File</a></li>
            
                <li><a href="../classes/FileFolder.html">FileFolder</a></li>
            
                <li><a href="../classes/Grade.html">Grade</a></li>
            
                <li><a href="../classes/GradeType.html">GradeType</a></li>
            
                <li><a href="../classes/Magister.html">Magister</a></li>
            
                <li><a href="../classes/MagisterSchool.html">MagisterSchool</a></li>
            
                <li><a href="../classes/Message.html">Message</a></li>
            
                <li><a href="../classes/MessageFolder.html">MessageFolder</a></li>
            
                <li><a href="../classes/Person.html">Person</a></li>
            
                <li><a href="../classes/ProfileInfo.html">ProfileInfo</a></li>
            
                <li><a href="../classes/StudyGuide.html">StudyGuide</a></li>
            
                <li><a href="../classes/StudyGuidePart.html">StudyGuidePart</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Magister.html">Magister</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: Magister.coffee</h1>

<div class="file">
    <pre class="code prettyprint linenums">
###*
# A JavaScript implementation of the Magister 6 API.
# @author Lieuwe Rooijakkers
# @module Magister
###

###*
# Class to communicate with Magister.
#
# @class Magister
# @param magisterSchool {MagisterSchool|String} A MagisterSchool to logon to. If this is a String it will use that String as a query to search for a possible school.
# @param username {String} The username of the user to login to.
# @param password {String} The password of the user to login to.
# @param [_keepLoggedIn=true] {Boolean} Whether or not to keep the user logged in.
# @constructor
###
class @Magister
	constructor: (@magisterSchool, @username, @password, @_keepLoggedIn = yes) -&gt;
		throw new Error &quot;Expected 3 or 4 arguments, got #{arguments.length}&quot; unless arguments.length is 3 or arguments.length is 4
		@_readyCallbacks = [] #Fixes weird bug where callbacks from previous Magister objects were mixed with the new ones.
		@http = new MagisterHttp()

		if _.isString(@magisterSchool)
			MagisterSchool.getSchools @magisterSchool, (e, r) =&gt;
				if e? then throw e
				else if r.length is 0 then throw new Error &quot;No school with the query #{@magisterSchool} found.&quot;
				else
					@magisterSchool = r[0]
					@reLogin()

		else @reLogin()

	###*
	# Get the appoinments of the current User between the two given Dates.
	#
	# @method appointments
	# @async
	# @param from {Date} The start date for the Appointments, you won&#x27;t get appointments from before this date.
	# @param [to] {Date} The end date for the Appointments, you won&#x27;t get appointments from after this date.
	# @param [download=true] {Boolean} Whether or not to download the users from the server.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Appointment[]} An array containing the Appointments.
	###
	appointments: -&gt;
		callback = _.find arguments, (a) -&gt; _.isFunction a
		download = _.find(arguments, (a) -&gt; _.isBoolean a) ? yes
		[from, to] = _.where arguments, (a) -&gt; _.isDate a
		unless _.isDate(to) then to = from

		@_forceReady()
		dateConvert = _helpers.urlDateConvert
		url = &quot;#{@_personUrl}/afspraken?tot=#{dateConvert(to)}&amp;van=#{dateConvert(from)}&quot;
		@http.get url, {},
			(error, result) =&gt;
				if error?
					callback error, null
				else
					result = EJSON.parse result.content
					appointments = (Appointment._convertRaw(@, a) for a in result.Items)
					absences = []

					hit = _helpers.asyncResultWaiter 3, (r) -&gt;
						for a in appointments
							do (a) -&gt; a._absenceInfo = _.find absences, (absence) -&gt; absence.appointmentId is a.id()

						_.remove appointments, (a) -&gt; _helpers.date(a.begin()) &lt; _helpers.date(from) or _helpers.date(a.end()) &gt; _helpers.date(to)
						callback null, _.sortBy appointments, (x) -&gt; x.begin()

					@http.get &quot;#{@_personUrl}/roosterwijzigingen?tot=#{dateConvert(to)}&amp;van=#{dateConvert(from)}&quot;, {}, (error, result) =&gt;
						appointments = _helpers.pushMore appointments, ( Appointment._convertRaw(@, c) for c in EJSON.parse(result.content).Items )
						hit()

					@http.get &quot;#{@_personUrl}/absenties?tot=#{dateConvert(to)}&amp;van=#{dateConvert(from)}&quot;, {}, (error, result) -&gt;
						result = EJSON.parse(result.content).Items
						for a in result
							do (a) -&gt; absences.push
								id: a.Id
								begin: new Date Date.parse a.Start
								end: new Date Date.parse a.Eind
								schoolHour: a.Lesuur
								permitted: a.Geoorloofd
								appointmentId: a.AfspraakId
								description: _helpers.trim a.Omschrijving
								type: a.VerantwoordingType
								code: a.Code
						hit()

					if download
						pushResult = _helpers.asyncResultWaiter appointments.length, -&gt; hit()

						for a in appointments
							do (a) =&gt;
								teachers = a.teachers() ? []

								@fillPersons teachers, ((e, r) -&gt;
									a._teachers = r
									pushResult()
								), 3
					else hit()

	###*
	# Gets the MessageFolders that matches the given query. Or if no query is given, all MessageFolders
	#
	# @method messageFolders
	# @param [query] {String} A case insensetive query the MessageFolder need to match.
	# @param [callback] {Function} Not useful at all, just here to prevent possible mistakes.
	#	@param [callback.error] {null} Will always be null
	#	@param [callback.result] {MessageFolder[]} An array containing the matching MessageFolders.
	# @return {MessageFolder[]} An array containing the matching messageFolders.
	###
	messageFolders: (query, callback) -&gt;
		@_forceReady()
		callback ?= (-&gt;)

		if _.isString(query) and query isnt &quot;&quot;
			result = _.where @_messageFolders, (mF) -&gt; _helpers.contains mF.name(), query, yes
		else
			result = @_messageFolders

		callback null, result
		return result
	###*
	# @method inbox
	# @return {MessageFolder} The inbox of the current user.
	###
	inbox: (callback = -&gt;) -&gt; @messageFolders(&quot;postvak in&quot;, (error, result) -&gt; if error? then callback(error, null) else callback(null, result[0]))[0]
	###*
	# @method sentItems
	# @return {MessageFolder} The sent items folder of the current user.
	###
	sentItems: (callback = -&gt;) -&gt; @messageFolders(&quot;verzonden items&quot;, (error, result) -&gt; if error? then callback(error, null) else callback(null, result[0]))[0]
	###*
	# @method bin
	# @return {MessageFolder} The bin of the current user.
	###
	bin: (callback = -&gt;) -&gt; @messageFolders(&quot;verwijderde items&quot;, (error, result) -&gt; if error? then callback(error, null) else callback(null, result[0]))[0]
	###*
	# @method alerts
	# @return {MessageFolder} The alerts folder of the current user.
	###
	alerts: (callback = -&gt;) -&gt; @messageFolders(&quot;mededelingen&quot;, (error, result) -&gt; if error? then callback(error, null) else callback(null, result[0]))[0]

	###*
	# Gets the courses of the current User.
	#
	# @method courses
	# @async
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Course[]} An array containing the Courses.
	###
	courses: (callback) -&gt;
		@_forceReady()
		url = &quot;#{@_personUrl}/aanmeldingen&quot;

		@http.get url, {},
			(error, result) =&gt;
				if error?
					callback error, null
				else
					result = EJSON.parse result.content
					callback null, _.sortBy (Course._convertRaw(@, c) for c in result.Items), (c) -&gt; c.begin()

	@_cachedPersons: {}
	###*
	# Gets an Array of Persons that matches the given profile.
	#
	# @method getPersons
	# @async
	# @param query {String} The query the persons must match to (e.g: Surname, Name, ...). Should at least be 3 chars long.
	# @param [type] {String|Number} The type the person must have. If none is given it will search for both Teachers and Pupils.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Person[]} An array containing the Persons.
	###
	getPersons: -&gt;
		@_forceReady()

		query = _helpers.trim arguments[0]
		callback = if arguments.length is 2 then arguments[1] else arguments[2]
		type = arguments[1] if arguments.length is 3

		unless query? and callback? and query.length &gt;= 3
			callback null, []
			return undefined

		unless type? # Try both Teachers and Pupils
			@getPersons query, 3, (e, r) =&gt;
				if e? then callback e, null
				else
					teachers = r
					@getPersons query, 4, (e, r) -&gt;
						if e? then callback e, null
						else callback null, _helpers.pushMore r, teachers
			return undefined

		type = switch Person._convertType type
			when 1 then &quot;Groep&quot;
			when 3 then &quot;Docent&quot;
			when 4 then &quot;Leerling&quot;
			when 8 then &quot;Project&quot;

			else &quot;Overig&quot;
		url = &quot;#{@_personUrl}/contactpersonen?contactPersoonType=#{type}&amp;q=#{query}&quot;

		if (val = Magister._cachedPersons[&quot;#{@_id}#{type}#{query}&quot;])?
			callback null, val
		else
			@http.get url, {}, (error, result) =&gt;
				if error?
					callback error, null
				else
					result = (Person._convertRaw(@, p) for p in EJSON.parse(result.content).Items)

					Magister._cachedPersons[&quot;#{@_id}#{type}#{query}&quot;] = result
					callback null, result

	###*
	# Fills the given person(s) by downloading the person from Magister and replacing the local instance.
	#
	# @method fillPersons
	# @async
	# @param persons {Person|Person[]} A Person or an Array of Persons to fetch more information for.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Person|Person[]} A fetched person or an array containing the fetched Persons, according to the type of the given persons parameter.
	# @param [overwriteType] {Number|String} Not recommended. Forces the type used to search the persons for.
	###
	fillPersons: (persons, callback, overwriteType) -&gt;
		if _.isArray persons
			if persons.length is 0
				callback null, []
				return undefined
			pushResult = _helpers.asyncResultWaiter persons.length, (r) -&gt; callback null, r
			
			for p in persons
				try
					@getPersons _.last(p.fullName().split &quot; &quot;), (p._type ? overwriteType), (e, r) -&gt;
						if e? or !r? then throw e
						else pushResult r[0] ? p
				catch
					pushResult p

		else if _.isObject persons
			try
				@getPersons _.last(persons.fullName().split &quot; &quot;), (persons._type ? overwriteType), (e, r) -&gt;
					if e? or !r? then throw e
					else callback null, r[0] ? persons
			catch
				callback persons

		else
			throw new Error &quot;Expected persons to be an Array or an Object, got a(n) #{typeof persons}&quot;

		return undefined

	###*
	# Shortcut for composing and sending a Message.
	#
	# @method composeAndSendMessage
	# @param subject {String} The subject of the message
	# @param [body] {String} The body of the message, if none is given the body will be empty.
	# @param recipients {Person[]|String[]|Person|String} The recipient(s) the message will be sent to.
	###
	composeAndSendMessage: -&gt;
		[subject, body] = _.filter arguments, (a) -&gt; _.isString a
		recipients = _.last arguments
		if arguments.length is 2 then body = &quot;&quot;

		m = new Message @
		m.subject subject
		m.body body ? &quot;&quot;
		m.addRecipient recipients
		m.send()

	###*
	# Gets the FileFolders of the current user.
	#
	# @method fileFolders
	# @async
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {FileFolder[]} An array containing FileFolders.
	###
	fileFolders: (callback) -&gt;
		@http.get &quot;#{@_personUrl}/bronnen?soort=0&quot;, {}, (error, result) =&gt;
			if error? then callback error, null
			else callback null, ( FileFolder._convertRaw @, f for f in EJSON.parse(result.content).Items )

	###*
	# Gets the StudyGuides of the current user.
	#
	# @method studyGuides
	# @async
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {StudyGuide[]} An array containing StudyGuides.
	###
	studyGuides: (callback) -&gt;
		@http.get &quot;#{@_pupilUrl}/studiewijzers?peildatum=#{_helpers.urlDateConvert new Date}&quot;, {}, (error, result) =&gt;
			if error? then callback error, null
			else callback null, ( StudyGuide._convertRaw @, s for s in EJSON.parse(result.content).Items )

	###*
	# Gets the Assignments for the current user.
	#
	# @method assignments
	# @async
	# @param [amount=25] {Number} The amount of Assignments to fetch from the server.
	# @param [skip=0] {Number} The amount of Assignments to skip.
	# @param [download=true] {Boolean} Whether or not to download the users from the server.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {Assignment[]} An array containing Assignments.
	###
	assignments: -&gt;
		[amount, skip] = _.filter arguments, (a) -&gt; _.isNumber a
		download = _.find arguments, (a) -&gt; _.isBoolean a
		callback = _.find arguments, (a) -&gt; _.isFunction a

		return unless callback?
		download ?= yes
		amount ?= 25
		skip ?= 0

		classes = null
		@courses (e, r) =&gt;
			if r? and r.length isnt 0
				_.last(r).classes (e, r) -&gt;
					classes = r if r? and r.length isnt 0

			@http.get &quot;#{@_personUrl}/opdrachten?skip=0&amp;top=25&amp;startdatum=#{_helpers.urlDateConvert new Date}&amp;status=alle&quot;, {}, (error, result) =&gt;
				if error? then callback error, null
				else
					result = (e.Id for e in EJSON.parse(result.content).Items)
					pushResult = _helpers.asyncResultWaiter result.length, (r) -&gt; callback null, r

					for id in result
						@http.get &quot;#{@_personUrl}/opdrachten/#{id}&quot;, {}, (error, result) =&gt;
							assignment = Assignment._convertRaw @, EJSON.parse(result.content)

							if classes? then assignment._class = _.find classes, (c) -&gt; c.abbreviation() is assignment._class

							if download
								teachers = assignment.teachers() ? []

								@fillPersons teachers, ((e, r) -&gt;
									assignment._teachers = r
									pushResult assignment
								), 3

							else pushResult assignment

	###*
	# Gets the Digital school utilities for the current user.
	#
	# @method digitalSchoolUtilities
	# @async
	# @fixme /NOT WORKING/ (Weird ID mismatch) @param [class] {Class|Number} The class or ID of a class to get the Digital school utitlities for. If none is given it will return every DigitalSchoolUtility.
	# @param callback {Function} A standard callback.
	# 	@param [callback.error] {Object} The error, if it exists.
	# 	@param [callback.result] {DigitalSchoolUtility[]} An array containing DigitalSchoolUtilities.
	###
	digitalSchoolUtilities: -&gt;
		#_class = _.find arguments, (a) -&gt; _.isNumber a or _.isObject a

		callback = _.find arguments, (a) -&gt; _.isFunction a
		return unless callback?

		_class = _class.id() if _.isObject _class

		url = if _class? then &quot;#{@_personUrl}/lesmateriaal?vakken=#{_class}&quot; else &quot;#{@_personUrl}/lesmateriaal&quot;

		classes = null
		@courses (e, r) =&gt;
			if r? and r.length isnt 0
				_.last(r).classes (e, r) -&gt;
					classes = r if r? and r.length isnt 0
			
			@http.get url, {}, (error, result) =&gt;
				if error? then callback error, null
				else
					utilities = ( DigitalSchoolUtility._convertRaw @, u for u in EJSON.parse(result.content).Items )

					if classes? then for u in utilities
						do (u) -&gt;
							u._class = _.find classes, (c) -&gt; c.abbreviation() is u._class.Afkorting and c.description() is u._class.Omschrijving

					callback null, utilities

	###*
	# Returns the profile for the current logged in user.
	#
	# @method profileInfo
	# @param [callback] {Function} Not useful at all, just here to prevent possible mistakes.
	#	@param [callback.error] {Null} Will always be null
	#	@param [callback.result] {ProfileInfo} The profile of the current logged in user.
	# @return {ProfileInfo} The profile of the current logged in user.
	###
	profileInfo: (callback) -&gt;
		@_forceReady()
		
		callback? null, @_profileInfo
		return @_profileInfo

	###*
	# Checks if this Magister instance is done logging in.
	#
	# You can also provide a callback, which will be called when this instance is done logging in.
	#
	# @method ready
	# @param [callback] {Function} The callback which will be called if the current instance is done logging in.
	# 	@param callback.magister {Magister} The current Magister instance.
	# @return {Boolean} Whether or not the current Magister instance is done logging in.
	###
	ready: (callback) -&gt;
		if _.isFunction callback
			if @_ready then callback @
			else @_readyCallbacks.push callback
		return @_ready is yes

	_forceReady: -&gt; throw new Error &quot;Not done with logging in! (use Magister.ready(callback) to be sure that logging in is done)&quot; unless @_ready
	_setReady: -&gt;
		@_ready = yes
		callback @ for callback in @_readyCallbacks
		@_readyCallbacks = []

	_readyCallbacks: []

	###*
	# (Re-)Login the current Magister instance.
	#
	# Usually not needed to call manually.
	#
	# @method reLogin
	# @deprecated
	###
	reLogin: -&gt;
		@_ready = no
		url = &quot;#{@magisterSchool.url}/api/sessie&quot;
		@http.post url,
			Gebruikersnaam: @username
			Wachtwoord: @password
			GebruikersnaamOnthouden: yes
			# if this works for every school, we actually wouldn&#x27;t need a &quot;relogin&quot; method. We will keep it and then see how it goes.
			IngelogdBlijven: @_keepLoggedIn
		, {headers: &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot; }, (error, result) =&gt;
			if error?
				throw new Error(error.message)
			else
				@_sessionId = /[a-z\d-]+/.exec(result.headers[&quot;set-cookie&quot;][0])[0]
				@http._cookie = &quot;SESSION_ID=#{@_sessionId}; M6UserName=#{@username}&quot;
				@http.get &quot;#{@magisterSchool.url}/api/account&quot;, {},
					(error, result) =&gt;
						result = EJSON.parse result.content
						@_group = result.Groep[0]
						@_id = result.Persoon.Id
						@_personUrl = &quot;#{@magisterSchool.url}/api/personen/#{@_id}&quot;
						@_pupilUrl = &quot;#{@magisterSchool.url}/api/leerlingen/#{@_id}&quot;
						@_profileInfo = ProfileInfo._convertRaw @, result

						@http.get &quot;#{@_personUrl}/berichten/mappen&quot;, {}, (error, result) =&gt;
							@_messageFolders = (MessageFolder._convertRaw(@, m) for m in EJSON.parse(result.content).Items)
							@_setReady()

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
